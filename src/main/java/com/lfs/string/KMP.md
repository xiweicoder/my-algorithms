# kmp思想

```
这时候，想到的是继续遍历Str1 的下一个字符，重复第1 步。(其实是很不明智的，因为此时BCD 已经比较过了，
没有必要再做重复的工作，一个基本事实是，当空格与D 不匹配时，你其实知道前面六个字符是”ABCDAB”。
KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这
样就提高了效率
```





```
a a b a a b a a f
a a b a a f
与其相等前缀的后面 (b)
找最长相等前后缀  (aa)
```



# 求前缀表

什么是前缀? ` 包含首字母,不包含尾字母的所有子串`



aabaaf的前后缀表:

|        |     前缀      |     后缀      | 最长相等前后缀长度 |
| :----: | :-----------: | :-----------: | :----------------: |
|   a    |      无       |      无       |         0          |
|   aa   |       a       |       a       |         1          |
|  aab   |     a,aa      |     b,ab      |         0          |
|  aaba  |   a,aa,aab    |    a,b,aba    |         1          |
| aabaa  | a,aa,aab,aaba | a,aa,baa,abaa |         2          |
| aabaaf |      无       |      无       |                    |



```
索引:    0 1 2 3 4 5 6 7 8
             	  ↓
    	a a b a a b a a f
    	a a b a a f
                  ↑
 前后缀: 0 1 0 1 2 0
 
 
 f前面a的next数组,2(最长相等后缀): 表示下次移动,移动到索引2位置上
 **这里有一个后缀aa,前面也有一个与其相等的前缀aa,在后缀的后面不匹配了,我们找与其相等前缀的后面开始匹配。** 这句话非常重要
与其相等前缀的后面下标(索引)是多少呢? 就是aabaa最长相等前后缀的长度
我们跳到索引为2的位置继续匹配,为什么?
2正好是前后缀的长度,我们的目的是要跳到前缀的后面开始匹配,前缀的后面正好是前后缀的长度2(索引比长度小1)


    下次匹配:
                      ↓
            a a b a a b a a f
            a a b a a f
                ↑           指针回退到b处开始匹配,此时就能够成功匹配
            0 1 0 1 2 0
        索引:0 1 2 3 4 5 6 7 8
```



# 为什么不会遗漏?

首先我们都知道，KMP算法的next数组可以指导匹配失败情况下，子串（模式串）的指针应该跳到哪里，而母串的指针是从来不会回头的。

假如在母串被跳跃过的部分中有个起点，恰好可以和子串匹配，那么我们不就错失正确答案了吗？

其实，这种情况是不会发生的，我们用的最长相同前后缀这个条件就限制了这种情况的发生。

下面用反证法来说明下：



```
反证法

    匹配初始状态: 最长相等前后缀为1 (A)
    A X X X X A ? X X X
    A X X X X A ?

    kmp算法移动后:
    A X X X X A ? X X X
              A X X X X A ?

  	假设有遗漏的情况: (假设此时完全匹配)
  	母串:                A X X X X A ? X X X
  	假设遗漏的子串:              A X X X X A ?


  	假设有遗漏: 假设此时完全匹配  补全字母:
  	母串:                     A X X A B A ? X A X
  	假设遗漏的子串:                   A B A X X A ?
                              A B A X X A ?    将假设遗漏的子串移动到初始位置, ?处是一定不相等的,不然也不会进行后续的移动

  	假设有遗漏: 假设此时完全匹配  继续补全字母:
  	母串:                     	A X X A B A ? X A X
  	假设遗漏的子串:                   	   A B A X X A ?
                           		  A B A A B A ?       母串和移动到初始位置的子串在?之前一定相等,不然不会在?时才移动(补全字母的前提)
    这时问题就出现了,子串的最长相等前后缀长度并不是1(A),而是3(ABA),这与我们最初前后缀的长度不一致,证毕!
```



# 代码实现前缀表

后缀为主串,前缀为模式串

j:前缀末尾  i:后缀末尾

**a b c a b** e e e **a b c a b** c 
			 **j						 i**

next[]实际上就是存了最长相等前后缀的长度

b串自己与自己匹配,B[1]-B[I]的前缀与它的后缀匹配



过程: 

aabaaf

```
           a a b a a f
索引        0 1 2 3 4 5
next数组:	  0 1 0 1 2 0	
                j    i
```



```java
    private void getNext(int[] next, String s) {
        /*
            j: 前缀末尾  i:后缀末尾
            j:还代表着i之前包括i子串的最长相等前后缀的长度
            s.length(): 模式串长度
            
            i和j为什么初始值不同? 因为求next数组是自匹配的过程，目的是求最大相等前后缀,只有一前一后才能代表前缀或者后缀,在这里i,j的含义也有所说明
         */
        int j = 0;
        next[0] = 0;// 第一位只会是0
        for (int i = 1; i < s.length(); i++) {
            /*
                不相等,持续回退,回退位置:前一个元素的next数组大小的索引处 且索引不能为负数
             */
            while (j > 0 && s.charAt(j) != s.charAt(i)) {
                j = next[j - 1];

            }
            if (s.charAt(j) == s.charAt(i)) {//匹配成功 i,j都向前移动一步
                j++;
            }
            next[i] = j;//填充next数组
        }
    }
```



# 前缀表如何使用

我们现在有一个next数组了[0 1 0 1 2  0]

定义j  = 0代表模式串的初始值 ; i = 0代表母串的初始值,这里与求next数组不同,求next数组是自匹配求最大前后缀,这里目的是判断串是否相等

判断是否相等:  **注意一定要先判断while**不然最后结果小1	

(重复判断while)不相等:	让当前子串的指针回退到 next数组的上一位 并以其作为索引的位置

相等: j++; i++;(i是永远++的)	

